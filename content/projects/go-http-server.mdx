---
title: "Go HTTP Server"
publishedAt: "2025-12-21"
description: "Create a HTTP server in go"
tags: ["Go","server"]
repositoryUrl: "https://github.com/miketeow/httpserver"
techStack: ["Go"]
---
# Introduction

This post documents my learning process regarding building an HTTP server in Go. Since I am still fairly new to Go, this post contains not only concepts about HTTP servers, but also some Go coding styles and practices that I discovered along the way.

## Server

Defining a basic server in Go looks like this:

```go
package main
import "net/http"

func main(){
	server := &http.Server{
		Addr: ":8080",
	}

	server.ListenAndServe()
}
```

The code is simple enough, feeling very similar to setting up a server with Express.js in JavaScript. However, since I’m new to Go, I wanted to dive into *why* we write it this way—specifically, that `&` ampersand.

In the [official Go documentation](https://pkg.go.dev/net/http#hdr-Servers), the examples always use the `&` symbol before `http.Server{}`. Interestingly, if I remove the ampersand, the compiler doesn't throw an error. This is because Go is smart enough to handle the conversion, but the underlying mechanics are important.

If you hover over `server.ListenAndServe()`, you’ll see the function signature requires a pointer receiver: `func (s *Server) ListenAndServe() error`.

We use a pointer here for two main reasons:

1.  **Efficiency:** A server struct is large. You generally only need one instance, and you don't want to pass around heavy copies of it throughout your program.
2.  **Safety:** The `http.Server` struct contains atomic fields (like `inShutdown`) to prevent race conditions. Go’s `sync/atomic` types must not be copied after first use. If you copy the server, you risk breaking the synchronization logic that keeps the server's state consistent.

<DeepDive title="Why Atomics Matter">

To understand why the server uses atomic fields, we have to look at how Go handles concurrency. An HTTP server must handle multiple requests simultaneously. If we used standard types to track state across these concurrent requests, we’d run into race conditions.

Consider a simple `Point` struct being updated by multiple goroutines:

```go
type Point struct {
	x int
}

func main() {
	p := Point{}
	var wg sync.WaitGroup

	for i := 0; i < 1000; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			p.x++ // <--- Race Condition!
		}()
	}

	wg.Wait()
	// Result: Likely less than 1000 because updates "stepped" on each other.
	fmt.Printf("Standard int result: %d\n", p.x)
}
```

To fix this, we use `sync/atomic`. This ensures that even when a thousand goroutines try to increment a value at once, each operation is completed fully before the next one starts.

```go
import "sync/atomic"

type AtomicPoint struct {
	x atomic.Int32
}

func main() {
	p := AtomicPoint{}
	var wg sync.WaitGroup

	for i := 0; i < 1000; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			p.x.Add(1) // <--- Atomic Transaction
		}()
	}

	wg.Wait()
	// Result: Guaranteed to be 1000
	fmt.Printf("Atomic int result: %d\n", p.x.Load())
}
```

Because `http.Server` manages its internal state using these same atomic principles to handle concurrent requests safely, we must treat it as a single, shared entity—hence the pointer.
</DeepDive>

### Style Tip: `&Server{}` vs. `new(Server)`

If you come from a Java or C# background, your instinct might be to use the `new` keyword. In Go, you *can* do that, but you'll rarely see it in production code.

```go
// Both of these create a pointer to a zero-valued Server
server1 := new(http.Server)
server2 := &http.Server{}
```

While they are functionally identical, the Go community almost exclusively prefers the **composite literal** (`&T{}`) for two reasons:

1.  **Consistency:** The `&T{}` syntax allows you to initialize fields immediately. `new(T)` only allows for zero-initialization, forcing you to use multiple lines to set up your struct.
2.  **Visual Clarity:** The `&` symbol is a loud, clear signal that "this is a pointer." In a language where memory address vs. value matters, having that explicit symbol right at the moment of creation is preferred.

**The Rule of Thumb:** Use `&T{}` for everything. Use `new(T)` only if you are feeling nostalgic or specifically want to emphasize that you are creating an empty, zero-initialized value.

### A Note on Memory: Escape Analysis

Since we are using `&http.Server`, we are dealing with pointers. In many languages, using a pointer (or the `new` keyword) explicitly tells the computer to put that data on the **Heap**.

In Go, the compiler is more intelligent. It uses a process called **Escape Analysis**. During compilation, Go looks at your code and asks: *"Does this variable 'escape' the function it was created in?"*

* **The Stack:** If the variable is only used inside the function, Go keeps it on the **Stack**. This is incredibly fast because the memory is reclaimed the moment the function finishes.
* **The Heap:** If the variable is returned from the function or shared with other parts of the program (like our server being passed around), it "escapes" to the **Heap**.

The beauty of Go is that you don't have to manually decide between Stack and Heap like you do in C or C++. You simply write your code naturally. If you use the `&` operator, the compiler decides the most efficient place to put it.

**Why should we care?** While we don't "control" it, we should be aware that "Heap = Work." Anything on the heap must eventually be cleaned up by the **Garbage Collector (GC)**. If we put too many things on the heap unnecessarily, our program might slow down while the GC works. By letting Go manage this, we get the safety of a managed language with performance that rivals lower-level languages.

## The Dangers of the `DefaultServeMux`

In Go, a `ServeMux` is an HTTP request multiplexer. Its job is to match the URL of an incoming request against a list of registered patterns and call the appropriate handler. It also handles path sanitization and pattern precedence.

Go provides a `DefaultServeMux` out of the box, but **you should almost never use it.**

The `DefaultServeMux` is a global variable stored in the `net/http` package. When you call package-level functions like `http.HandleFunc("/", ...)`, you are modifying this global instance.

```go
func main() {
	server := &http.Server{
		Addr: ":8080",
	}

	// This modifies the GLOBAL mux!
	http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
		fmt.Fprint(w, "Hello from the DEFAULT mux!")
	})

	server.ListenAndServe()
}
```

### The "Malicious Library" Scenario

The danger of a global variable is that *anyone* can change it. In Go, the `init()` function runs automatically when a package is imported. If you import a third-party library—even if you don't use any of its functions—that library can secretly register routes to your server.

Imagine a malicious "analytics" package:

```go
package analytics

import (
	"fmt"
	"net/http"
)

func init() {
	// This registers to the GLOBAL mux automatically on import!
	http.HandleFunc("/malicious", func(w http.ResponseWriter, r *http.Request) {
		fmt.Fprint(w, "I have poisoned the global DefaultServeMux!")
	})
}
```

If you import this package using the "blank import" (`_`), the library's `init()` function runs, and suddenly your server is hosting a route you didn't authorize:

```go
import (
	"net/http"
	_ "testproject/analytics" // Secretly runs analytics.init()
)

func main() {
	server := &http.Server{Addr: ":8080"}
	server.ListenAndServe()
	// localhost:8080/malicious is now active!
}
```

### The Solution: Explicit Muxing

To prevent this, you should always create your own local `ServeMux`. By passing your custom mux into the `http.Server` struct, you ensure the server only knows about the routes you explicitly defined.

```go
func main() {
	// 1. Create a private multiplexer
	mux := http.NewServeMux()

	// 2. Register handlers to your private mux
	mux.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
		fmt.Fprint(w, "Hello from a safe, private mux!")
	})

	// 3. Inject the mux into the server
	server := &http.Server{
		Addr:    ":8080",
		Handler: mux,
	}

	server.ListenAndServe()
}
```

Now, even if a library tries to poison the `DefaultServeMux`, your server is shielded because it isn't using the global instance.

## Serving Static Files Safely

If you are building a web server that needs to serve HTML, CSS, or images, Go provides a built-in `http.FileServer`. This handler takes an incoming HTTP request and maps it to the file system.

### The "Development" Trap

During early development, it’s tempting to serve everything from your root directory:

```go
func main() {
	mux := http.NewServeMux()

	// DANGER: Serving the root directory
	mux.Handle("/", http.FileServer(http.Dir(".")))

	server := &http.Server{
		Addr:    ":8081",
		Handler: mux,
	}
	server.ListenAndServe()
}
```

This works for seeing your <File>index.html</File>, but it creates a massive security flaw. A malicious user could visit <Url>localhost:8081/main.go</Url> or <Url>localhost:8081/go.mod</Url> and read your entire backend source code.

### The Secure Approach: Isolation and StripPrefix

To secure the server, you must isolate your public assets into a dedicated folder like <File>./public</File> and use `http.StripPrefix`. The `http.StripPrefix` function is necessary because of how the `FileServer` looks for files.

If a user visits <Url>localhost:3000:/app</Url>, the `FileServer` will try to find a file at <File>./public/app/index.html</File>. Since the <File>/app</File> folder doesn't exist inside <File>/public</File>, it would return a 404. We need to strip the `/app/` prefix so the `FileServer` only sees <File>index.html</File>.

```go
func main() {
	mux := http.NewServeMux()

	// 1. Create a handler that only looks inside the "public" folder
	fsHandler := http.FileServer(http.Dir("./public"))

	// 2. Use StripPrefix to remove "/app/" from the request URL
	// before it reaches the file server.
	mux.Handle("/app/", http.StripPrefix("/app/", fsHandler))

	server := &http.Server{
		Addr:    ":8081",
		Handler: mux,
	}

	fmt.Println("Server starting on :8081")
	server.ListenAndServe()
}
```

With this setup, the visitor is "jailed" within the <File>./public</File> folder. They can access <Url>yoursite.com/app/</Url>, but they can never move "up" the directory tree to access your private source code or environment variables.

## Stateful Handlers: Moving Beyond Global Variables

A classic "Hello World" in Go looks like this:

```go
mux.HandleFunc("/app/hello", func(w http.ResponseWriter, r *http.Request) {
    w.Header().Add("Content-Type", "text/plain; charset=utf-8")
    w.WriteHeader(http.StatusOK)
    w.Write([]byte("Hello World"))
})
```

But what if we want to track state—like a counter that increments every time a user visits? Your first instinct might be to use a global variable:

```go
var globalHits atomic.Int32

func main() {
    // ...
    mux.HandleFunc("/app/hits", func(w http.ResponseWriter, r *http.Request) {
        globalHits.Add(1)
        fmt.Println(globalHits.Load())
    })
}
```

While this works, it’s a maintenance nightmare. As your app grows, you’ll have database connections, platform settings, and multiple counters. Scattering these as globals makes your code hard to test and even harder to read.

### The "Shared Brain": The apiConfig Struct

The idiomatic Go solution is to bundle everything related to your app’s state into a single struct. We then turn our handlers into **methods** of that struct using a "pointer receiver."

```go
type apiConfig struct {
    fileserverHits atomic.Int32
    query      *database.Queries
    platform       string
}

// This method is "bound" to our config struct
func (cfg *apiConfig) handlerMetrics(w http.ResponseWriter, r *http.Request) {
    cfg.fileserverHits.Add(1)
    w.WriteHeader(http.StatusOK)
    w.Write([]byte(fmt.Sprintf("Hits: %d", cfg.fileserverHits.Load())))
}
```

By doing this, we achieve **Dependency Injection**. Any function attached to `apiConfig` immediately knows how to talk to the database or increment the hit counter without needing global variables.

---

## Middleware: The "Handler Factory"

A standalone handler is great, but what if you want to count hits on *every* request—including requests for static files? You don’t want to manually add `cfg.fileserverHits.Add(1)` to every single route. This is where **Middleware** comes in.

Think of middleware as a **factory**. It takes an existing handler, wraps it in a "costume," and returns a new handler. The signature looks like this: `func(next http.Handler) http.Handler`.

### Building the Metric Middleware

Here is how we turn our hit counter into a bridge that sits between the server and the final destination:

```go
func (cfg *apiConfig) middlewareMetricsInc(next http.Handler) http.Handler {
    // We return a "HandlerFunc" which is a type cast that
    // gives our anonymous function the required ServeHTTP method.
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        cfg.fileserverHits.Add(1) // 1. Do our work (increment counter)
        next.ServeHTTP(w, r)      // 2. Pass the baton to the next handler
    })
}
```

### The "Domino Effect" in Reality

It is important to remember that the Go server itself has no idea what "middleware" is. When we write this line:

`mux.Handle("/app/", cfg.middlewareMetricsInc(fsHandler))`

The function `middlewareMetricsInc` runs **immediately** (at startup), creates an anonymous function that "captures" the `fsHandler`, and hands that anonymous function to the `ServeMux`. When a request actually arrives, here is the real sequence:

1.  **The Server calls the Product:** The server executes the `ServeHTTP` method of the **anonymous function** created by our factory.
2.  **The Work Happens:** Inside that anonymous function, our code increments the counter: `cfg.fileserverHits.Add(1)`.
3.  **The Baton Pass:** The anonymous function then calls `next.ServeHTTP(w, r)`. Because it "captured" the `fsHandler` earlier, this call triggers the FileServer's logic.

This is why we call it a chain. Each handler is responsible for calling the next one. If our anonymous function forgot to call `next.ServeHTTP`, the request would simply stop there—the "domino" effect would be broken, and the FileServer would never run.

## Database Infrastructure

### Docker

For development, I use Docker to spin up a PostgreSQL instance. While my Go application performs a `db.Ping()` at startup, I also implemented a Docker-level `healthcheck` using `pg_isready`.

This provides a higher level of infrastructure reliability. It prevents the "startup race condition" where the Go app tries to connect before the database is actually ready to accept connections. By adding this check, Docker ensures the database service is "Healthy" before dependent services attempt to communicate with it.

```yml
services:
  db:
    image: postgres:18-alpine
    container_name: testserver-db
    environment:
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=password
      - POSTGRES_DB=test_chirpy
    ports:
      - "5432:5432"
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres -d test_chirpy"]
      interval: 10s
      timeout: 5s
      retries: 5
    volumes:
      - pgdata:/var/lib/postgresql/data

volumes:
  pgdata:

```

### Tooling: Goose and SQLC

In Go, it is standard practice to separate build-time tools from runtime dependencies. To keep my application binaries clean—containing only the standard library `database/sql` and the necessary driver `lib/pq`—I use two specific tools:

1.  **[Goose](https://github.com/pressly/goose):** For version-controlled database migrations.
2.  **[SQLC](https://docs.sqlc.dev/en/latest/overview/install.html):** To generate type-safe Go code from raw SQL.

This setup prevents "ORM bloat" and gives us the performance of raw SQL with the safety of a compiled language.

Configuration for `sqlc` lives in <File>sqlc.yaml</File>, telling it where to find my queries and where to output the Go code:

```yaml
version: "2"
sql:
  - schema: "sql/schema"
    queries: "sql/queries"
    engine: "postgresql"
    gen:
      go:
        package: "database"
        out: "internal/database"

```

### Migrations

We define our schema in <File>sql/schema</File>. Standard convention is to number files sequentially like <File>001_users.sql</File> so the tool knows the order of execution.

```sql
-- +goose Up
CREATE TABLE users (
    id UUID PRIMARY KEY,
    created_at TIMESTAMP NOT NULL,
    updated_at TIMESTAMP NOT NULL,
    email TEXT UNIQUE NOT NULL,
    hashed_password TEXT NOT NULL DEFAULT 'unset'
);

-- +goose Down
DROP TABLE users;
```

The annotations `-- +goose Up` and `-- +goose Down` are directives for the tool.

* **Up:** Defines how to apply the change.
* **Down:** Defines how to undo the change.

In a professional environment, the "Down" migration is critical for rolling back changes if a deployment fails. When we run `goose postgres "{$DB_URL}" up`, Goose creates a `goose_db_version` table to track which migrations have already run, ensuring we don't apply the same change twice.

### SQL Queries

With the table created, we can write our queries in <File>sql/queries/users.sql</File>.

```sql title="users.sql"
-- name: CreateUser :one
INSERT INTO users (id, created_at, updated_at, email, hashed_password)
VALUES ($1, $2, $3, $4, $5)
RETURNING *;

-- name: GetUserByEmail :one
SELECT * FROM users WHERE email = $1;

```

Note the `RETURNING *` clause. In older SQL, an `INSERT` was "blind"—it didn't return data. You would have to insert the row and then immediately run a `SELECT` to get the data back (a two-round-trip process).

Modern PostgreSQL allows `INSERT`, `UPDATE`, and `DELETE` statements to behave like `SELECT`s. By using `RETURNING *`, the database inserts the row and returns the full object in a single, atomic transaction. This is faster and guarantees that the data we get back is exactly what was stored.

### Wiring it up in Main

Finally, we need to initialize the database connection in <File>main.go</File> and inject it into our `apiConfig` struct.

**Important:** We must import the postgres driver `lib/pq` using the blank identifier `_`. This registers the driver with Go's `database/sql` package without us needing to call its functions directly.

```go title="main.go"
// top of the file
import (
  "os"
	"sync/atomic"
  "database/sql"
  "time"
	"github.com/google/uuid"
	"github.com/joho/godotenv"
	"github.com/mengkhaiteow/httpserver/internal/database"
  _ "github.com/lib/pq"
)

type apiConfig struct {
	fileserverHits atomic.Int32
	query          *database.Queries
}

func main() {
	godotenv.Load()
	dbURL := os.Getenv("DB_URL")
	db, err := sql.Open("postgres", dbURL)
	err = db.Ping()
	if err != nil {
		log.Fatal("Could not connect to DB:", err)
		return
	}
	dbQueries := database.New(db)
	apiCfg := &apiConfig{
		fileserverHits: atomic.Int32{},
		query:          dbQueries,
	}
}

```

## The User Handler: Parsing and Creating

Now that `sqlc` has generated our type-safe database functions, we can wire them up in <File>main.go</File>.

### Parsing JSON

Since we are building an HTTP server, we deal with streaming data. To read the request body, we use a `json.Decoder`. Unlike `json.Unmarshal` (which requires loading the whole JSON into memory first), the decoder processes the stream directly from the request body, which is more efficient for an HTTP server.

We define a struct to match the expected JSON structure. (Note: You can define this struct inside the handler function to keep the global namespace clean).

```go title="main.go"

func (cfg *apiConfig) handleUsersCreate(w http.ResponseWriter, r *http.Request) {
	type parameters struct {
		Email    string `json:"email"`
		Password string `json:"password"`
	}

	decoder := json.NewDecoder(r.Body)
	params := parameters{}
	err := decoder.Decode(&params)
	if err != nil {
		respondWithError(w, http.StatusBadRequest, "Invalid request payload")
		return
	}

    // ... continued below
}
```

### Context: The "Kill Switch"

When calling our database function, you'll notice we pass `r.Context()`:

```go title="main.go"
	hashedPassword, err := auth.HashPassword(params.Password)
	if err != nil {
		respondWithError(w, http.StatusInternalServerError, "Couldn't hash password")
		return
	}

	user, err := cfg.query.CreateUser(r.Context(), database.CreateUserParams{
		ID:             uuid.New(), // Generate the ID here!
		CreatedAt:      time.Now().UTC(),
		UpdatedAt:      time.Now().UTC(),
		Email:          params.Email,
		HashedPassword: hashedPassword,
	})
```

Why pass context? `Context` acts as a **kill switch** for the request.

Imagine a user sends a complex search query that takes the database 30 seconds to process. If the user gets impatient and closes their browser tab after 2 seconds, the request is cancelled.

1.  The server receives the cancellation signal.
2.  The `r.Context()` becomes "Done".
3.  The database driver sees this and immediately stops the query, freeing up resources.

Without context, your database would keep crunching numbers for a ghost user.

### The Importance of DTOs (Data Transfer Objects)

After creating the user, we need to return the data. It is tempting to simply return the struct generated by `sqlc`:

```go title="models.go"
// Generated by SQLC
type User struct {
	ID             uuid.UUID `json:"id"`
	Email          string    `json:"email"`
	HashedPassword string    `json:"hashed_password"` // <--- DANGER
}
```

However, we should **never** return this directly. We need to create a custom "Response Struct" (or DTO) for three reasons:

**1. Security: The Leaky Abstraction**
The internal model contains implementation details like `HashedPassword`. Even if it's hashed, you never want to expose security internals to the frontend.

**2. Aggregated Fields**
Internal database normalization rules don't always match what the UI needs.

* **Database:** Stores `first_name` and `last_name` columns.
* **API:** Returns a computed `full_name` field.

By using a DTO, we can format the data for the user without cluttering the database with redundant columns.

**3. API Stability: Compile vs. Runtime Errors**
This is the most subtle but powerful reason. Imagine we rename the database column `content` to `message`.

* **Without DTO:** `sqlc` updates the JSON tag automatically. The API response changes from `{"content": "..."}` to `{"message": "..."}`. The frontend code (which expects `content`) breaks silently in production—a dangerous **Runtime Error**.
* **With DTO:** You have to manually map `dbUser.Message` to `dtoUser.Content`. When you rename the DB column, your mapping code breaks immediately because the field `Message` doesn't exist on the struct yet. The compiler forces you to fix it—a strict **Compile-time Error**.

We would always rather fix a bug at compile time than have it crash in production.

```go title="main.go"
// Define a clean response struct
type UserResponse struct {
	ID        uuid.UUID `json:"id"`
	Email     string    `json:"email"`
	CreatedAt time.Time `json:"created_at"`
}

// Map internal -> external
func (cfg *apiConfig) handleUsersCreate(w http.ResponseWriter, r *http.Request) {
    // ... create user logic ...

    respondWithJSON(w, http.StatusCreated, UserResponse{
        ID:        user.ID,
        Email:     user.Email,
        CreatedAt: user.CreatedAt,
    })
}
```
